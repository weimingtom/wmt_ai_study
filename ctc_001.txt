https://www.cnblogs.com/qcloud1001/p/9041218.html

腾讯云加社区
博客园首页新随笔联系订阅管理随笔 - 769  文章 - 4  评论 - 862
语音识别中的CTC算法的基本原理解释
欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~

本文作者：罗冬日

目前主流的语音识别都大致分为特征提取，声学模型，语音模型几个部分。目前结合神经网络的端到端的声学模型训练方法主要CTC和基于Attention两种。

本文主要介绍CTC算法的基本概念，可能应用的领域，以及在结合神经网络进行CTC算法的计算细节。

CTC算法概念
CTC算法全称叫：Connectionist temporal classification。从字面上理解它是用来解决时序类数据的分类问题。

传统的语音识别的声学模型训练，对于每一帧的数据，需要知道对应的label才能进行有效的训练，在训练数据之前需要做语音对齐的预处理。而语音对齐的过程本身就需要进行反复多次的迭代，来确保对齐更准确，这本身就是一个比较耗时的工作。



上图是“你好”这句话的声音的波形示意图， 每个红色的框代表一帧数据，传统的方法需要知道每一帧的数据是对应哪个发音音素。比如第1,2,3,4帧对应n的发音，第5,6,7帧对应i的音素，第8,9帧对应h的音素，第10,11帧对应a的音素，第12帧对应o的音素。（这里暂且将每个字母作为一个发音音素）

与传统的声学模型训练相比，采用CTC作为损失函数的声学模型训练，是一种完全端到端的声学模型训练，不需要预先对数据做对齐，只需要一个输入序列和一个输出序列即可以训练。这样就不需要对数据对齐和一一标注，并且CTC直接输出序列预测的概率，不需要外部的后处理。

既然CTC的方法是关心一个输入序列到一个输出序列的结果，那么它只会关心预测输出的序列是否和真实的序列是否接近（相同），而不会关心预测输出序列中每个结果在时间点上是否和输入的序列正好对齐。


CTC引入了blank（该帧没有预测值），每个预测的分类对应的一整段语音中的一个spike（尖峰），其他不是尖峰的位置认为是blank。对于一段语音，CTC最后的输出是spike（尖峰）的序列，并不关心每一个音素持续了多长时间。
如图2所示，拿前面的nihao的发音为例，进过CTC预测的序列结果在时间上可能会稍微延迟于真实发音对应的时间点，其他时间点都会被标记会blank。
这种神经网络+CTC的结构除了可以应用到语音识别的声学模型训练上以外，也可以用到任何一个输入序列到一个输出序列的训练上（要求：输入序列的长度大于输出序列）。
比如，OCR识别也可以采用RNN+CTC的模型来做，将包含文字的图片每一列的数据作为一个序列输入给RNN+CTC模型，输出是对应的汉字，因为要好多列才组成一个汉字，所以输入的序列的长度远大于输出序列的长度。而且这种实现方式的OCR识别，也不需要事先准确的检测到文字的位置，只要这个序列中包含这些文字就好了。

RNN+CTC模型的训练
下面介绍在语音识别中，RNN+CTC模型的训练详细过程，到底RNN+CTC是如何不用事先对齐数据来训练序列数据的。
首先，CTC是一种损失函数，它用来衡量输入的序列数据经过神经网络之后，和真实的输出相差有多少。

比如输入一个200帧的音频数据，真实的输出是长度为5的结果。 经过神经网络处理之后，出来的还是序列长度是200的数据。比如有两个人都说了一句nihao这句话，他们的真实输出结果都是nihao这5个有序的音素，但是因为每个人的发音特点不一样，比如，有的人说的快有的人说的慢，原始的音频数据在经过神经网络计算之后，第一个人得到的结果可能是：nnnniiiiii...hhhhhaaaaaooo(长度是200)，第二个人说的话得到的结果可能是：niiiiii...hhhhhaaaaaooo(长度是200)。这两种结果都是属于正确的计算结果，可以想象，长度为200的数据，最后可以对应上nihao这个发音顺序的结果是非常多的。CTC就是用在这种序列有多种可能性的情况下，计算和最后真实序列值的损失值的方法。

详细描述如下：

训练集合为S={(x1,z1),(x2,z2),...(xN,zN)}, 表示有N个训练样本，x是输入样本，z是对应的真实输出的label。一个样本的输入是一个序列，输出的label也是一个序列，输入的序列长度大于输出的序列长度。

对于其中一个样本(x,z)，x=(x1,x2,x3,...,xT)表示一个长度为T帧的数据，每一帧的数据是一个维度为m的向量，即每个xi∈Rm。 xi可以理解为对于一段语音，每25ms作为一帧，其中第i帧的数据经过MFCC计算后得到的结果。

z=(z1,z2,z3,...zU)表示这段样本语音对应的正确的音素。比如，一段发音“你好”的声音，经过MFCC计算后，得到特征x， 它的文本信息是“你好”，对应的音素信息是z=[n,i,h,a,o](这里暂且将每个拼音的字母当做一个音素)。

特征x在经过RNN的计算之后，在经过一个softmax层，得到音素的后验概率y。 ytk(k=1,2,3,...n,t=1,2,3,...,T)表示在t时刻，发音为音素k的概率，其中音素的种类个数一共n个， k表示第k个音素，在一帧的数据上所有的音素概率加起来为1。即：

∑Tt−1ytk=1,ytk≥0

这个过程可以看做是对输入的特征数据x做了变换Nw:(Rm)T→(Rn)T，其中Nw表示RNN的变换，w表示RNN中的参数集合。

过程入下图所示：


以一段“你好”的语音为例，经过MFCC特征提取后产生了30帧，每帧含有12个特征，即x∈R30×14(这里以14个音素为例，实际上音素有200个左右)，矩阵里的每一列之和为1。后面的基于CTC-loss的训练就是基于后验概率y计算得到的。

路径π和B变换
在实际训练中并不知道每一帧对应的音素，因此进行训练比较困难。可以先考虑一种简单的情况，已知每一帧的音素的标签z′， 即训练样本为x和z′，其中z′不再是简单的[n,i,h,a,o]标签，而是：

z′=[n,n,n,...,nT1,i,i,i,...iT2,h,h,h,...hT3,a,a,a,...,aT4,o,o,o,...,oT5]

T1+T2+T3+T4+T5=T
在我们的例子中， z′=[n,n,n,n,n,n,n,i,i,i,i,i,i,h,h,h,h,h,h,h,a,a,a,a,a,a,o,o,o,o,o,o,o]， $z\prime 包含了每一帧的标签。在这种情况下有：p(z\prime|x) = p(z\prime| y = N_w(x)) = y^1_{z\prime_1}y^2_{z\prime_2}y^3_{z\prime_3}....y^T_{z\prime_T}$  (1)

该值即为后验概率图中用黑线圈起来的部分相乘。我们希望相乘的值越大越好，因此，数学规划可以写为：

minw−log(y1z′1.y2z′2.y3z′3...yTz′T)  (2)

subject to: y=Nw(x) (3)

目标函数对于后验概率矩阵y中的每个元素ytk的偏导数为：
∂−log(y1z′1.y2z′2.y3z′3...yTz′T)∂ytk=$\begin{cases} -\frac{y^1_{z\prime_1}...y^{i-1}{z\prime{i-1}}.y^{i+1}{z\prime{i+1}}....y^T_{z\prime_T}}{y^1_{z^\prime_1}.y^2_{z^\prime_2}.y^3_{z^\prime_3}...y^T_{z^\prime_T}} , \qquad if \qquad k = z\prime_i \qquad and \qquad t=i \ 0 \qquad 其他\end{cases}$

也就是说，在每个时刻t(对应矩阵的一列）,目标只与ytz′t是相关的，在这个例子中是与被框起来的元素相关。

其中Nw可以看做是RNN模型，如果训练数据的每一帧都标记了正确的音素，那么训练过程就很简单了，但实际上这样的标记过的数据非常稀少，而没有逐帧标记的数据很多，CTC可以做到用未逐帧标记的数据做训练。

首先定义几个符号：
L={a,o,e,i,u,uˇ,b,p,m,...}

表示所有音素的集合

π=(π1,π2,π3,...,πT),πi∈L

表示一条由L中元素组成的长度为T的路径，比如z′就是一条路径，以下为几个路径的例子：

π1=(j,j,i,n,y,y,e,e,w,w,u,u,u,r,r,e,e,n,n,r,r,u,u,sh,sh,u,u,i,i)
π2=(n,n,n,n,i,i,i,i,h,h,h,h,a,a,a,a,a,a,a,a,a,o,o,o,o,o,o,o,o,o)
π3=(h,h,h,h,h,h,a,a,a,a,a,a,a,o,o,o,o,n,n,n,n,n,n,i,i,i,i,i,i,i)
π4=(n,i,h,a,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o)
π5=(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,i,h,a,o)
π6=(n,n,n,i,i,i,h,h,h,h,h,a,,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o)

这6条路径中，π1可以被认为是“今夜无人入睡”， π2可以被认为是在说“你好”，π3可以被认为是在说“好你”，π4,π5,π6都可以认为是在说“你好”。

定义B变换，表示简单的压缩，例如：
B(a,a,a,b,b,b,c,c,d)=(a,b,c,d)

以上6条路径为例：
B(π1)=(j,i,n,y,e,w,u,r,e,n,r,u,s,h,u,i)
B(π2)=(n,i,h,a,)
B(π3)=(h,a,o,n,i)
B(π4)=(n,i,h,a,o)
B(π5)=(n,i,h,a,o)
B(π6)=(n,i,h,a,o)

因此，如果有一条路径π有B(π)=(n,i,h,a,o)，则可以认为π是在说“你好”。即使它是如π4所示，有很多“o”的音素，而其他音素很少。路径π=(π1,π2,...,πT)的概率为它所经过的矩阵y上的元素相乘：

p(π|x)=p(π|y=Nw(x))=p(π|y)=∏Tt=1ytπt

因此在没有对齐的情况下，目标函数应该为{π|B(π)=z}中所有元素概率之和。 即：
maxwp(z|y=Nw(x))=p(z|x)=∑B(π)=zp(π|x)  (4)

在T=30，音素为[n,i,h,a,o]的情况下，共有C529≈120000条路径可以被压缩为[n,i,h,a,o]。 路径数目的计算公式为C音素个数T−1，量级大约为(T−1)音素个数。一段30秒包含50个汉字的语音，其可能的路径数目可以高达108，显然这么大的路径数目是无法直接计算的。因此CTC方法中借用了HMM中的向前向后算法来计算。

训练实施方法
CTC的训练过程是通过∂p(z|x)∂w调整w的值使得4中的目标值最大，而计算的过程如下：


因此，只要得到$\frac {\partial p(z|x)}{\partial y^t_k} ，即可根据反向传播，得到\frac {\partial p(z|x)}{\partial w} $。下面以“你好”为例，介绍该值的计算方法。

首先，根据前面的例子，找到所有可能被压缩为z=[n,i,h,a,o]的路径，记为{π|B(π)=z}。 可知所有π均有[n,n,n,....,n,i,.....,i,h,.....h,a,....a,o,...,o]的形式，即目标函数只与后验概率矩阵y中表示n,i,h,a,o的5行相关，因此为了简便，我们将这5行提取出来，如下图所示。


在每一个点上，路径只能向右或者向下转移，画出两条路径，分别用q和r表示，这两条路径都经过y14h这点，表示这两点路径均在第14帧的时候在发“h”音。因为在目标函数4的连加项中，有的项与y14h无关，因此可以剔除这一部分，只留下与y14h有关的部分，记为{π|B(π)=z,π14=h}

∂p(z|y)∂y14h
= ∂∑B(π)=zp(π|y)∂y14h
= $\frac {\partial \sum_{B(\pi)=z}\prod_{t=1}^T y^t_{\pi_t}}{\partial y^{14}h} =\frac {\overbrace{\partial \sum{B(\pi)=z,\pi_{14}=h}\prod_{t=1}^T y^t_{\pi_t}}^{和y^{14}h有关的项} + \overbrace{\partial \sum{B(\pi)=z,\pi_{14} \neq h}\prod_{t=1}^T y^t_{\pi_t}}^{和y^{14}_h无关的项}}{\partial y^{14}_h}$

=∂∑B(π)=z,π14=h∏Tt=1ytπt∂y14h

这里的q和r就是与y14h相关的两条路径。用q1:13和q15:30分别表示q在y14h之前和之后的部分，同样的，用r1:13和r15:30分别表示r在y14h之前和之后的部分.。可以发现，q1:13+h+r15:30与r1:13+h+q15:30同样也是两条可行的路径。q1:13+h+r15:30、r1:13+h+q15:30、q 、r这四条路径的概率之和为：
y1q1..y13q13.y14h.y15q15....y30q30路径q的概率

+y1q1..y13q13.y14h.y15r15....y30r30路径q1:14+r14:30的概率

+y1r1..y13r13.y14h.y15q15....y30q30路径r1:14+q14:30的概率

+y1r1..y13r13.y14h.y15r15....y30r30路径r的概率

=(y1q1....y13q13+y1r1.....y13r13).y14h.(y15q15....y30q15+y15r15....y30r30)

可以发现，该值可以总结为：（前置项）.y14h.(后置项)。由此，对于所有的经过y14h的路径，有：

∑B(π)=z,π14=h∏Tt=1ytπt=(前置项).y14h.(后置项)$

定义：
$\alpha_(14)(h)=(前置项).y^{14}h = \sum{B(\pi_{1:14})=[n,i,h] }\prod_{t\prime=1}^t y^{t\prime}{\pi{t\prime}} $

该值可以理解为从初始到y14h这一段里，所有正向路径的概率之和。并且发现，α14(h)可以由α13(h)和α13(i)递推得到，即：
α14(h)=(α13(h)+α13(i))y14h

该递推公式的含义是，只是在t=13时发音是“h”或“i”，在t=14时才有可能发音是“h”。那么在t=14时刻发音是“h”的所有正向路径概率α14(h)就等于在t=13时刻，发音为“h”的正向概率α13(h)加上发音为“i”的正向概率α13(i)，再乘以当前音素被判断为“h”的概率y14h。由此可知，每个αt(s)都可以由αt−1(s)和αt−1(s−1)两个值得到。α的递推流程如下图所示：



即每个值都由上一个时刻的一个或者两个值得到，总计算量大约为2.T.音素个数。类似的，定义βt(s)， 递推公式为：

β14(h)=(β15(h)+β15(a))y14h

因此有：

∑B(π)=z,π14=h∏Tt=1ytπt=(前置项).y14h.(后置项)$

=α14(h)y14h.y14h.β14(h)y14h

=α14(h)β14(h)y14h

然后：

∂p(z|y)∂y14h
= ∑B(π)=z,π14=h∏Tt=1ytπt∂y14h

= α14(h)y14h.y14h.β14(h)y14h∂y14h

=α14(h)β14(h)(y14h)2

得到此值后，就可以根据反向传播算法进行训练了。
可以看到，这里总的计算量非常小，计算α和β的计算量均大约为(2.T.音素个数)，（加法乘法各一次），得到α和β之后，在计算对每个ytk的偏导值的计算量为(3.T.音素个数)，因此总计算量大约为(7.T.音素个数)，这是非常小的，便于计算。

目前，深度学习的算法已经大规模应用于腾讯云的语音识别产品中。腾讯云拥有业内最先进的语音识别技术，基于海量的语音数据，积累了数十万小时的标注语音数据，采用LSTM，CNN，LFMMI，CTC等多种建模技术，结合超大规模语料的语言模型，对标准普通话的识别效果超过了97%的准确率。腾讯云的语音技术，应用涵盖范围广泛，具备出色的语音识别、语音合成、关键词检索、静音检测、语速检测、情绪识别等能力。并且针对游戏，娱乐，政务等几十个垂直做特殊定制的语音识别方案，让语音识别的效果更精准，更高效，全面满足电话客服质检、语音听写、实时语音识别和直播字幕等多种场景的应用。想试用相关产品吗？请猛戳：cloud.tencent.com/product/asr

问答
语音识别API如何调用？
相关阅读
智能机器人语音识别技术
python语音识别终极指南
tensorflow LSTM +CTC实现端到端OCR

此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1122128?fromSource=waitui


海量技术实践经验，尽在云加社区！ https://cloud.tencent.com/developer

